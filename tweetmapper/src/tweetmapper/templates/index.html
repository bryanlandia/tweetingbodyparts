<!DOCTYPE html>
<meta charset="utf-8">
<body>
<!-- <h1>Americans tweeting about their bits</h1> -->

<link rel="stylesheet" type="text/css" href="/static/css/style.css" />
<script src="http://d3js.org/d3.v3.min.js" charset="utf-8"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.0/jquery.min.js"></script>
<script>

(function() {

		var width = 1100,
	    height = 600,
	    projection;


		var svg = d3.select("body").append("svg")
	    .attr("width", width)
	    .attr("height", height);

		d3.json("/static/data/us.json", function(error, us) {
		  if (error) return console.error(error);
		  console.log(us);

		  var land = topojson.feature(us, us.objects.land);
		  projection = d3.geo.albersUsa()
		  	.scale(1100)
		  	.translate([width/2, height/2]);

		  var path = d3.geo.path()
	    	.projection(projection);

		  svg.append("path")
	      	.datum(land)
	      	.attr("d", path);

	     update_points();

		});

		function key_on_lat_lng_w_variance(d){
			/* for now we aren't really doing this
			   but the idea is to try to return a range of
			   points for joining... not sure if that 
			   would work
			*/
			return d.pt;
		}

		function changed_subject_only(d, el) {			
			if (el.__old_data__ == undefined) return null; //new els won't have
			// debugger;
			return (d.subject != el.__old_data__.subject) ? el: null;
		}

		function add_points(points) {
			// add point if it doesn't already exist
			// key on lat/long only, not subject
			// key on lat/long within random variance of step
			var join = svg.selectAll('image.bpart')
				.property("__old_data__", function(d){ return d;})
				.data(points, key_on_lat_lng_w_variance)
			    ;	
			join.attr("part", function(d){return d.subject});
			join.enter()				
			    .append("svg:image")
			    .attr("xlink:href", function(d) {
			    	return "/static/img/"+d.subject+".png";
			    })
			    .attr("x", function(d) {
			      return projection(d.pt)[0]-13;
			    })
			    .attr("y", function(d) {
			      return projection(d.pt)[1]-13;
			    })
			    .attr("width", 27)
			    .attr("height", 27)
			    .attr("class", "bpart")
			    .style("opacity", 0)
			    .transition()
			    	.duration(function(d){return Math.random()*d.pt[1]*100})
			    	.style("opacity", 0.7)
			    ;
			join.exit()
				.transition()
					.duration(1000)
					.style("opacity", 0)
					.remove(); // fade out and delete if not present in data

			// in/out opacity transition on only those w/ chanaged subjects
			join.filter(function(d, i){return changed_subject_only(d, this)})
				.transition()					
					.duration(1000)
			    	.style("opacity", 0)
	    		.transition()
			    	.duration(1000)
			    	.style("opacity", 0.7)
			;    	
		}

		function update_points() {
		    $.ajax({
            type: "GET",
            contentType: "application/json; charset=utf-8",
            url: '/data',
            dataType: 'json',
            async: true,
            cache: false,
            success: function (data) {
            	// write new points to map				
            	// debugger
            	if (data){
            		var points = new Array();
                    for (var loc in data) {
                    	if (data.hasOwnProperty(loc)) {
	                    	point = {'pt': loc.split(","), 'subject':data[loc]};
	                    	points.push(point);
					   	}
				    }
				    add_points(points);					    
               }
            },
            error: function(xhr, textStatus, errorThrown){
               console.log(textStatus + ', ' + errorThrown);
          	}
	    	})
		}

		var intv_id = setInterval(update_points, 5 * 1000);

	})(jQuery);


</script>
</body>
</html>